#!/usr/bin/python

from __future__ import print_function
import xml.etree.ElementTree as ET
import string
import datetime
import os
import getpass
import math

input_file = "merged_iso_table_a1.xml"
output_file = 'iso_table_data.h'

# The template for the entire C/C++ file to be generated

template = string.Template("""
#ifndef ISOMON_ISO_TABLE_DATA_H
#define ISOMON_ISO_TABLE_DATA_H

/******************************************************************
** THIS FILE AUTOMATICALLY GENERATED by $script
** by $user from $input_file on $today.
** Instead of manually editing this file, you probably want to
** manually edit $input_file and regenerate this file.
******************************************************************/

#ifdef __cplusplus
  #include <cstddef>
  #include <tr1/cstdint>
#else
  #include <stddef.h>
  #include <stdint.h>
#endif

enum {
  $codes
};

#define ISOMON_ISONUM_COUNT 1024
#define ISOMON_MINOR_SCALE_COUNT 16

#if !defined(ISOMON_INCLUDE_DEFINITIONS)

extern size_t g_isomon_hash_count;
extern int32_t g_hash_to_isonum[ISOMON_ISONUM_COUNT];
extern char g_isonum_to_code[ISOMON_ISONUM_COUNT][4];
extern int16_t g_isonum_to_hash[ISOMON_ISONUM_COUNT];
extern uint8_t g_isonum_to_minor_scale[ISOMON_ISONUM_COUNT/2];
extern int8_t g_minor_scale_to_num_digits[ISOMON_MINOR_SCALE_COUNT];
extern int16_t g_minor_scale_to_num_minors[ISOMON_MINOR_SCALE_COUNT];

#else

#define ISOMON_CODE2HASH(ch0,ch1,ch2) \\
  (((((ch0 & 0x1F) << 5) | (ch1 & 0x1F)) << 5) | (ch2 & 0x1F))

#define ISOMON_HASH_ISONUM_PAIR(hash, isonum) \\
  ((hash << 16) + isonum)

size_t g_isomon_hash_count = $hash_count;

int32_t g_hash_to_isonum[ISOMON_ISONUM_COUNT] = {
  $hash_to_num
};

char g_isonum_to_code[ISOMON_ISONUM_COUNT][4] = {
  $num_to_code
};

int16_t g_isonum_to_hash[ISOMON_ISONUM_COUNT] = {
  $num_to_hash
};

/* isonum_to_minor_scale holds number of decimal places needed for minor units.
** Each byte covers two ISO numeric codes, so 4-bits (1 hex digit) each.
** For ISO numeric code, the number of minor unit decimal places is
** isonum_to_minor_scale[n / 2] >> (4 * (n % 2))
** Hex digit F represent unknown or not applicable number of minor units.
*/

uint8_t g_isonum_to_minor_scale[ISOMON_ISONUM_COUNT/2] = {
  $num_to_minor
};

int8_t g_minor_scale_to_num_digits[ISOMON_MINOR_SCALE_COUNT] = {
  $num_digits
};

int16_t g_minor_scale_to_num_minors[ISOMON_MINOR_SCALE_COUNT] = {
  $num_minors
};

#endif

#endif // ISOMON_ISO_TABLE_DATA_H
"""[1:])


# Parse XML data into dictionaries

code_to_num = dict()
num_to_code = dict()
num_to_minor = dict()

root = ET.parse(input_file).getroot()
for elem in root:
    if elem.tag != 'ISO_CURRENCY':
        print("WARNING! Element " + elem.tag + " instead of ISO_CURRENCY!")
    d = dict( (s.tag, s.text) for s in elem.getiterator() )
    code = d['ALPHABETIC_CODE']
    if code is not None:
        num = d['NUMERIC_CODE']
        if num is None :
            print("WARNING! " + code + " has no numeric code.")
        else :
            if num == 'Nil': num = 0
            else : num = int(num)
            code_to_num[code] = num
            num_to_code[num] = code
        minor = d['MINOR_UNIT']
        if minor.isdigit() :
            num_to_minor[num] = minor


# Convert dictionaries into lines of C++

currency_code_lines = []
strs = []
for code in sorted(code_to_num) :
    strs.append( "ISO_{} ={: 4d}".format(code, code_to_num[code]) )
    if (len(strs) >= 5) :
        currency_code_lines.append(', '.join(strs))
        strs = []
if (len(strs) > 0) :
    currency_code_lines.append(', '.join(strs))

code_to_num_lines = [
  "ISOMON_HASH_ISONUM_PAIR( ISOMON_CODE2HASH('{}','{}','{}'), ISO_{})".format(
      code[0], code[1], code[2], code)
  for code in sorted(code_to_num)
]

num_to_code_lines = []
for row in range(0, 103) :
    strs = []
    for col in range(0, 10) :
        num = 10*row + col
        if num < 1024 :
            if (num in num_to_code) :
                strs.append('"' + num_to_code[num] + '"')
            else :
                strs.append('   ""')
    num_to_code_lines.append(', '.join(strs))

num_to_hash_lines = []
strs = []
for num in range(0, 1024) :
    if (num in num_to_code) :
        code = num_to_code[num]
        strs.append( "ISOMON_CODE2HASH('{}','{}','{}')".format(
          code[0], code[1], code[2]) )
    else :
        strs.append("                            0")
    if (len(strs) >= 2) :
        num_to_hash_lines.append(',   '.join(strs))
        strs = []
if (len(strs) > 0) :
    num_to_hash_lines.append(',   '.join(strs))

num_to_minor_lines = []
max_minor = 0
for row in range(0,52) :
    strs = []
    for col in range(0,10) :
        num = 20*row + 2*col
        if num < 1024 :
            x = '0x'
            for i in [1, 0] :
                if num+i in num_to_minor :
                    x += num_to_minor[num+i]
                    if (int(num_to_minor[num+i]) > max_minor) :
                        max_minor = int(num_to_minor[num+i])
                else :
                    x += 'F'
            strs.append(x)
    num_to_minor_lines.append(', '.join(strs))

num_digits = []
num_minors = []
for scale in range(0, max_minor+1) :
    num_digits.append( str(int(scale)) )
    num_minors.append( str(int(math.pow(10, scale))) )
for scale in range(max_minor+1, 16) :
    num_digits.append( str(0) )
    num_minors.append( str(0) )


### Now finally write out the header file

f = open(output_file, 'w')

f.write(template.substitute(
    user = getpass.getuser(),
    script = os.path.basename(__file__),
    input_file = input_file,
    today = datetime.datetime.now().strftime("%Y-%m-%d"),
    codes = ",\n  ".join(currency_code_lines),
    hash_count = len(code_to_num_lines),
    hash_to_num = ",\n  ".join(code_to_num_lines),
    num_to_code = ",\n  ".join(num_to_code_lines),
    num_to_hash = ",\n  ".join(num_to_hash_lines),
    num_to_minor = ",\n  ".join(num_to_minor_lines),
    num_digits = ", ".join(num_digits),
    num_minors = ", ".join(num_minors)
))

